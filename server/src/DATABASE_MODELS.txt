]633;E;for file in models/*.js\x3b do echo ""\x3b echo "================================================================================"\x3b echo "FILE: $file"\x3b echo "================================================================================"\x3b cat "$file"\x3b done > DATABASE_MODELS.txt && wc -l DATABASE_MODELS.txt;b70644bf-1870-4cb4-81bc-4fd7305e9aa4]633;C
================================================================================
FILE: models/Analytics.js
================================================================================
import mongoose from "mongoose";

/**
 * Analytics Schema
 * 
 * For user behavior tracking - captures events like
 * product views, add to cart, checkout, design uploads.
 */

const AnalyticsSchema = new mongoose.Schema(
  {
    /* =====================
       EVENT INFO
    ====================== */
    eventType: {
      type: String,
      enum: [
        "PRODUCT_VIEW",
        "ADD_TO_CART",
        "REMOVE_FROM_CART",
        "CHECKOUT_START",
        "CHECKOUT_COMPLETE",
        "DESIGN_UPLOAD",
        "SEARCH",
        "FILTER_APPLY",
        "CATEGORY_VIEW",
        "LOGIN",
        "SIGNUP",
        "LOGOUT",
      ],
      required: true,
      index: true,
    },

    /* =====================
       REFERENCES
    ====================== */
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      index: true,
    },

    productId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Product",
      index: true,
    },

    categoryId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Category",
    },

    orderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
    },

    /* =====================
       SESSION TRACKING
    ====================== */
    sessionId: {
      type: String,
      index: true,
    },

    /* =====================
       TIMESTAMP
    ====================== */
    timestamp: {
      type: Date,
      default: Date.now,
      index: true,
    },

    /* =====================
       EVENT METADATA
    ====================== */
    metadata: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
      // Event-specific data
      // e.g., { searchQuery: "business cards", quantity: 100 }
    },

    /* =====================
       DEVICE INFO
    ====================== */
    deviceInfo: {
      type: {
        type: String, // "MOBILE", "DESKTOP", "TABLET"
      },
      os: String,
      browser: String,
      userAgent: String,
      screenWidth: Number,
      screenHeight: Number,
    },

    /* =====================
       LOCATION
    ====================== */
    location: {
      ip: String,
      country: String,
      state: String,
      city: String,
      pincode: String,
      latitude: Number,
      longitude: Number,
    },

    /* =====================
       REFERRER
    ====================== */
    referrer: {
      source: String, // "GOOGLE", "FACEBOOK", "DIRECT", "EMAIL"
      medium: String, // "CPC", "ORGANIC", "REFERRAL"
      campaign: String,
      url: String,
    },

    /* =====================
       PAGE CONTEXT
    ====================== */
    pageUrl: String,
    pageTitle: String,
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
AnalyticsSchema.index({ eventType: 1, timestamp: -1 });
AnalyticsSchema.index({ userId: 1, timestamp: -1 });
AnalyticsSchema.index({ productId: 1, timestamp: -1 });
AnalyticsSchema.index({ sessionId: 1, timestamp: 1 });

// TTL index - auto-delete after 1 year (optional)
// AnalyticsSchema.index({ timestamp: 1 }, { expireAfterSeconds: 365 * 24 * 60 * 60 });

/* =====================
   STATIC METHODS
====================== */

/**
 * Track an event
 */
AnalyticsSchema.statics.track = async function (eventData) {
  return await this.create({
    ...eventData,
    timestamp: new Date(),
  });
};

/**
 * Get product views count
 */
AnalyticsSchema.statics.getProductViews = async function (productId, days = 30) {
  const since = new Date();
  since.setDate(since.getDate() - days);

  return await this.countDocuments({
    eventType: "PRODUCT_VIEW",
    productId,
    timestamp: { $gte: since },
  });
};

export default mongoose.model("Analytics", AnalyticsSchema);

================================================================================
FILE: models/AttributeRuleSchema.js
================================================================================
import mongoose from "mongoose";

const AttributeRuleSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },

    /* =====================
       WHEN (CONDITION)
    ====================== */
    when: {
      attribute: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "AttributeType",
        required: true,
      },
      value: {
        type: String, // SubAttribute.value
        required: true,
      },
    },

    /* =====================
       THEN (ACTIONS)
    ====================== */
    then: [
      {
        action: {
          type: String,
          enum: [
            "SHOW",
            "HIDE",
            "SHOW_ONLY",
            "SET_DEFAULT",
            "TRIGGER_PRICING",
          ],
          required: true,
        },

        targetAttribute: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "AttributeType",
        },

        /* UI ACTION DATA */
        allowedValues: [String],
        defaultValue: String,

        /* PRICING SIGNAL ONLY */
        pricingSignal: {
          pricingKey: String,
          scope: {
            type: String,
            enum: ["GLOBAL", "ZONE", "SEGMENT", "PRODUCT", "ATTRIBUTE"],
          },
          priority: {
            type: Number,
            default: 0,
          },
        },
      },
    ],

    /* =====================
       APPLICABILITY
    ====================== */
    applicableCategory: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Category",
    },

    applicableProduct: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Product",
    },

    applicableUserSegments: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "UserSegment",
      },
    ],

    applicableGeoZones: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "GeoZone",
      },
    ],

    priority: {
      type: Number,
      default: 0,
    },

    isActive: {
      type: Boolean,
      default: true,
    },
  },
  { timestamps: true }
);

/* =====================
   INDEXES
===================== */
AttributeRuleSchema.index({ priority: -1 });
AttributeRuleSchema.index({ applicableCategory: 1 });
AttributeRuleSchema.index({ applicableProduct: 1 });
AttributeRuleSchema.index({ applicableUserSegments: 1 });
AttributeRuleSchema.index({ applicableGeoZones: 1 });
AttributeRuleSchema.index({ isActive: 1 });

export default mongoose.model("AttributeRule", AttributeRuleSchema);

================================================================================
FILE: models/attributeTypeModal.js
================================================================================
import mongoose from "mongoose";

const AttributeTypeSchema = new mongoose.Schema(
  {
    /* =========================
       BASIC IDENTITY
    ========================= */
    attributeName: {
      type: String,
      required: true,
      trim: true,
    },

    /* =========================
       SYSTEM ROLE
    ========================= */
    functionType: {
      type: String,
      enum: ["QUANTITY_PRICING", "PRINTING_IMAGE", "SPOT_UV_IMAGE", "GENERAL"],
      default: "GENERAL",
    },

    /* =========================
       PRICING BEHAVIOR
    ========================= */
    pricingBehavior: {
      type: String,
      enum: ["NONE", "SIGNAL_ONLY", "QUANTITY_DRIVER"],
      default: "NONE",
    },

    /* =========================
       UI INPUT CONFIG
    ========================= */
    inputStyle: {
      type: String,
      enum: [
        "DROPDOWN",
        "TEXT_FIELD",
        "FILE_UPLOAD",
        "NUMBER",
        "CHECKBOX",
        "RADIO",
        "POPUP",
      ],
      default: "DROPDOWN",
    },

    displayOrder: {
      type: Number,
      default: 0,
    },

    /* =========================
       QUANTITY CONFIG
       (only for QUANTITY_DRIVER)
    ========================= */
    quantityConfig: {
      quantityType: {
        type: String,
        enum: ["SIMPLE", "STEP_WISE", "RANGE_WISE"],
        default: "SIMPLE",
      },

      minQuantity: Number,
      maxQuantity: Number,
      quantityMultiples: Number,

      stepWiseQuantities: [Number],

      rangeWiseQuantities: [
        {
          min: { type: Number, required: true },
          max: Number,
          priceMultiplier: { type: Number, default: 1.0 },
          label: String,
        },
      ],
    },

    /* =========================
       EFFECT AREA
    ========================= */
    primaryEffectType: {
      type: String,
      enum: ["PRICE", "FILE", "VARIANT", "INFORMATIONAL"],
      default: "INFORMATIONAL",
    },

    effectDescription: {
      type: String,
      default: "",
    },

    /* =========================
       FILTERING
    ========================= */
    isFilterable: {
      type: Boolean,
      default: false,
    },

    /* =========================
       DEFAULT VALUE (leaf SubAttribute.value)
    ========================= */
    defaultValue: {
      type: String,
    },

    /* =========================
       VISIBILITY SCOPE
    ========================= */
    isCommonAttribute: {
      type: Boolean,
      default: false,
    },

    applicableCategories: [
      { type: mongoose.Schema.Types.ObjectId, ref: "Category" },
    ],

    applicableSubCategories: [
      { type: mongoose.Schema.Types.ObjectId, ref: "SubCategory" },
    ],
  },
  { timestamps: true }
);

/* =========================
   INDEXES
========================= */
AttributeTypeSchema.index({ attributeName: 1 });
AttributeTypeSchema.index({ pricingBehavior: 1 });
AttributeTypeSchema.index({ isCommonAttribute: 1 });

export default mongoose.model("AttributeType", AttributeTypeSchema);

================================================================================
FILE: models/categoryModal.js
================================================================================
import mongoose from "mongoose";

const CategorySchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    description: String,
    image: String,
    type: {
      type: String,
      required: true,
      enum: ["Digital", "Bulk"],
      default: "Digital",
    },
    // Optional parent category for unlimited depth hierarchy
    parent: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Category",
      default: null,
    },
    // Sort order for displaying subcategories (lower numbers appear first)
    sortOrder: {
      type: Number,
      default: 0,
    },
    // Slug for URL-friendly identifiers (optional, auto-generated if not provided)
    slug: { 
      type: String, 
      unique: true,
      sparse: true, // Allow null values for uniqueness
    },
  },
  { timestamps: true }
);

// Index for faster parent queries
CategorySchema.index({ parent: 1 });
CategorySchema.index({ type: 1, parent: 1 });
CategorySchema.index({ parent: 1, sortOrder: 1 }); // For sorting children by order

export default mongoose.model("Category", CategorySchema);

================================================================================
FILE: models/ComplaintSchema.js
================================================================================
import mongoose from "mongoose";

const ComplaintSchema = new mongoose.Schema(
  {
    /* =====================
       CORE REFERENCES
    ====================== */
    order: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
      required: true,
      index: true,
      unique: true // ðŸ”’ ONE complaint per order (STRICT)
    },

    raisedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true
    },

    registeredByRole: {
      type: String,
      enum: ["CUSTOMER", "ADMIN", "EMP"],
      required: true
    },

    /* =====================
       COMPLAINT DETAILS
    ====================== */
    type: {
      type: String,
      enum: ["PRICE", "QUALITY", "DELIVERY"],
      required: true
    },

    description: {
      type: String,
      required: true
    },

    /* =====================
       ðŸ”’ IMMUTABLE PRICE SNAPSHOT
       (Only for PRICE complaints)
    ====================== */
    priceSnapshot: {
      type: mongoose.Schema.Types.Mixed
    },

    /* =====================
       ELIGIBILITY CONTROL
    ====================== */
    allowedUntil: {
      type: Date,
      required: true,
      index: true
    },

    /* =====================
       RESOLUTION WORKFLOW
    ====================== */
    resolutionStatus: {
      type: String,
      enum: ["OPEN", "IN_REVIEW", "RESOLVED", "REJECTED"],
      default: "OPEN",
      index: true
    },

    resolutionNotes: {
      type: String,
      default: ""
    },

    resolvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User"
    },

    resolvedAt: Date,

    /* =====================
       REOPEN & ESCALATION
    ====================== */
    reopenCount: {
      type: Number,
      default: 0
    },

    lastReopenedAt: Date,

    escalationLevel: {
      type: Number,
      default: 0
    },

    /* =====================
       NEW FIELDS
    ====================== */
    timeLimit: {
      type: Number,
      // 7 for customers, 15 for agents
    },

    complaintSource: {
      type: String,
      enum: ["WEBSITE", "CHAT", "CALL", "WHATSAPP", "EMAIL"],
    },

    existingComplaintId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Complaint",
      // For single complaint rule
    },

    reopenedCount: {
      type: Number,
      default: 0,
    },

    assignedTo: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      index: true,
    },

    resolutionType: {
      type: String,
      enum: ["REPRINT", "PRIORITY_PROCESSING", "REFUND", "OTHER"],
    },

    reprintOrderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
      // If reprint approved
    },

    notificationLogs: [
      {
        sentAt: { type: Date, default: Date.now },
        type: { type: String, enum: ["EMAIL", "WHATSAPP", "SMS"] },
        recipient: String,
        status: { type: String, enum: ["SENT", "DELIVERED", "FAILED"] },
        messageId: String,
      },
    ],
  },
  { timestamps: true }
);

/* =====================
   IMMUTABLE PRICE SNAPSHOT
====================== */
ComplaintSchema.pre("save", function (next) {
  if (!this.isNew && this.isModified("priceSnapshot")) {
    return next(new Error("Price snapshot is immutable once saved"));
  }
  next();
});

/* =====================
   ORDER STATE VALIDATION
====================== */
ComplaintSchema.pre("validate", async function (next) {
  const Order = mongoose.model("Order");
  const order = await Order.findById(this.order);

  if (!order) {
    return next(new Error("Order not found"));
  }

  if (order.status !== "DELIVERED") {
    return next(new Error("Complaint allowed only after order delivery"));
  }

  next();
});

/* =====================
   INDEXES
====================== */
ComplaintSchema.index({ order: 1 });
ComplaintSchema.index({ resolutionStatus: 1 });
ComplaintSchema.index({ raisedBy: 1, createdAt: -1 });

export default mongoose.model("Complaint", ComplaintSchema);

================================================================================
FILE: models/CorporateProfile.js
================================================================================
import mongoose from "mongoose";

const CorporateProfileSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true
    },

    organizationName: { type: String, required: true },

    organizationType: {
      type: String,
      enum: [
        "PRIVATE_LIMITED",
        "LLP",
        "LIMITED",
        "GOVERNMENT",
        "HOSPITAL",
        "SCHOOL",
        "INSTITUTE",
        "NGO",
        "FRANCHISE",
        "OTHER"
      ],
      required: true
    },

    authorizedPersonName: { type: String, required: true },

    designation: {
      type: String,
      enum: [
        "PURCHASE_MANAGER",
        "MARKETING_HEAD",
        "ADMIN",
        "FINANCE_MANAGER",
        "DIRECTOR",
        "OTHER"
      ],
      required: true
    },

    mobileNumber: { type: String, required: true },
    whatsappNumber: String,
    officialEmail: { type: String, required: true },

    gstNumber: { type: String, required: true },

    address: {
      fullAddress: String,
      city: String,
      state: String,
      pincode: String
    },

    proofDocument: {
      type: String, // Letterhead / PO / ID
      required: true
    },

    verificationStatus: {
      type: String,
      enum: ["PENDING", "APPROVED", "REJECTED"],
      default: "PENDING"
    },

    verifiedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User"
    },

    verifiedAt: Date
  },
  { timestamps: true }
);

export default mongoose.model("CorporateProfile", CorporateProfileSchema);

================================================================================
FILE: models/CrossSellAnalytics.js
================================================================================
import mongoose from "mongoose";

/**
 * CrossSellAnalytics Schema
 * 
 * For cross-sell recommendations - tracks which products
 * are frequently viewed/purchased together.
 */

const CrossSellAnalyticsSchema = new mongoose.Schema(
  {
    /* =====================
       PRODUCT PAIR
    ====================== */
    sourceProduct: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Product",
      required: true,
      index: true,
    },

    targetProduct: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Product",
      required: true,
      index: true,
    },

    /* =====================
       METRICS
    ====================== */
    viewCount: {
      type: Number,
      default: 0,
      min: 0,
      // Times targetProduct was viewed after sourceProduct
    },

    purchaseCount: {
      type: Number,
      default: 0,
      min: 0,
      // Times both products were purchased together
    },

    addToCartCount: {
      type: Number,
      default: 0,
      min: 0,
    },

    /* =====================
       COMPUTED METRICS
    ====================== */
    conversionRate: {
      type: Number,
      default: 0,
      min: 0,
      max: 1,
      // purchaseCount / viewCount
    },

    confidence: {
      type: Number,
      default: 0,
      min: 0,
      max: 1,
      // Statistical confidence in the recommendation
    },

    /* =====================
       SCORING
    ====================== */
    score: {
      type: Number,
      default: 0,
      index: true,
      // Weighted score for recommendation ranking
    },

    /* =====================
       TIMING
    ====================== */
    lastUpdated: {
      type: Date,
      default: Date.now,
      index: true,
    },

    /* =====================
       CATEGORY INFO (for faster queries)
    ====================== */
    sourceCategory: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Category",
    },

    targetCategory: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Category",
    },
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
CrossSellAnalyticsSchema.index(
  { sourceProduct: 1, targetProduct: 1 },
  { unique: true }
);
CrossSellAnalyticsSchema.index({ sourceProduct: 1, score: -1 });
CrossSellAnalyticsSchema.index({ lastUpdated: -1 });

/* =====================
   METHODS
====================== */

/**
 * Increment view count and recalculate metrics
 */
CrossSellAnalyticsSchema.methods.incrementView = async function () {
  this.viewCount += 1;
  this.recalculateMetrics();
  return this.save();
};

/**
 * Increment purchase count and recalculate metrics
 */
CrossSellAnalyticsSchema.methods.incrementPurchase = async function () {
  this.purchaseCount += 1;
  this.recalculateMetrics();
  return this.save();
};

/**
 * Recalculate derived metrics
 */
CrossSellAnalyticsSchema.methods.recalculateMetrics = function () {
  // Conversion rate
  this.conversionRate = this.viewCount > 0 
    ? this.purchaseCount / this.viewCount 
    : 0;

  // Confidence (simplified - based on sample size)
  const sampleSize = this.viewCount + this.purchaseCount;
  this.confidence = Math.min(1, sampleSize / 100);

  // Score (weighted combination)
  this.score = (this.conversionRate * 0.6 + this.confidence * 0.4) * 100;

  this.lastUpdated = new Date();
};

/* =====================
   STATIC METHODS
====================== */

/**
 * Get recommendations for a product
 */
CrossSellAnalyticsSchema.statics.getRecommendations = async function (
  productId,
  limit = 5
) {
  return await this.find({
    sourceProduct: productId,
    score: { $gt: 10 }, // Minimum score threshold
  })
    .sort({ score: -1 })
    .limit(limit)
    .populate("targetProduct", "name image");
};

/**
 * Record a view event
 */
CrossSellAnalyticsSchema.statics.recordView = async function (
  sourceProductId,
  targetProductId
) {
  const record = await this.findOneAndUpdate(
    {
      sourceProduct: sourceProductId,
      targetProduct: targetProductId,
    },
    {
      $inc: { viewCount: 1 },
      $set: { lastUpdated: new Date() },
    },
    {
      upsert: true,
      new: true,
    }
  );

  record.recalculateMetrics();
  return record.save();
};

/**
 * Record a purchase event
 */
CrossSellAnalyticsSchema.statics.recordPurchase = async function (productIds) {
  // For each pair of products purchased together
  for (let i = 0; i < productIds.length; i++) {
    for (let j = 0; j < productIds.length; j++) {
      if (i !== j) {
        await this.findOneAndUpdate(
          {
            sourceProduct: productIds[i],
            targetProduct: productIds[j],
          },
          {
            $inc: { purchaseCount: 1 },
            $set: { lastUpdated: new Date() },
          },
          { upsert: true }
        );
      }
    }
  }
};

export default mongoose.model("CrossSellAnalytics", CrossSellAnalyticsSchema);

================================================================================
FILE: models/departmentModal.js
================================================================================
import mongoose from "mongoose";

const DepartmentSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
      unique: true,
    },
    description: {
      type: String,
      trim: true,
    },
    isEnabled: {
      type: Boolean,
      default: true,
    },
    operators: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
      },
    ],

    /* =====================
       NEW FIELDS - Production Workflow Control
    ====================== */
    sequenceOrder: {
      type: Number,
      default: 0,
    },

    canStart: {
      type: Boolean,
      default: true,
    },

    canPause: {
      type: Boolean,
      default: true,
    },

    canStop: {
      type: Boolean,
      default: true,
    },

    defaultDuration: {
      type: Number, // in minutes
    },

    requiredOperators: {
      type: Number,
      default: 1,
      min: 1,
    },

    equipment: [
      {
        type: String,
        trim: true,
      },
    ],

    checklist: [
      {
        type: String,
        trim: true,
      },
    ],
  },
  { timestamps: true }
);

// Index for faster queries
DepartmentSchema.index({ isEnabled: 1 });

export default mongoose.model("Department", DepartmentSchema);


================================================================================
FILE: models/DesignerSession.js
================================================================================
import mongoose from "mongoose";

/**
 * DesignerSession Schema
 * 
 * For "Hire a Designer" service - tracks sessions between
 * customers and designers for custom design work.
 */

const DesignerSessionSchema = new mongoose.Schema(
  {
    /* =====================
       CORE REFERENCES
    ====================== */
    orderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
      index: true,
    },

    customerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },

    designerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },

    /* =====================
       SESSION CONFIG
    ====================== */
    sessionType: {
      type: String,
      enum: ["VISUAL", "PHYSICAL"],
      required: true,
    },

    status: {
      type: String,
      enum: ["SCHEDULED", "ACTIVE", "COMPLETED", "CANCELLED"],
      default: "SCHEDULED",
      index: true,
    },

    startTime: Date,
    endTime: Date,

    duration: {
      type: Number, // in minutes
      min: 0,
    },

    /* =====================
       PAYMENT
    ====================== */
    paymentStatus: {
      type: String,
      enum: ["PENDING", "PAID"],
      default: "PENDING",
    },

    amount: {
      type: Number,
      min: 0,
    },

    /* =====================
       SESSION HISTORY
    ====================== */
    historyLogs: [
      {
        timestamp: { type: Date, default: Date.now },
        message: String,
        userId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
      },
    ],

    /* =====================
       ARTIFACTS
    ====================== */
    artifacts: [
      {
        type: {
          type: String,
          enum: ["CHAT_LOG", "REFERENCE_IMAGE", "NOTE", "RECORDING"],
        },
        content: String, // URL or text
        uploadedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        uploadedAt: { type: Date, default: Date.now },
      },
    ],

    /* =====================
       DESIGN REQUIREMENTS
    ====================== */
    designRequirements: {
      cardFor: String,
      designStyle: String,
      colorPreference: String,
      language: String,
      logoAvailable: { type: Boolean, default: false },
      logoUrl: String,
      photoAvailable: { type: Boolean, default: false },
      photoUrl: String,
      specialInstructions: String,
    },
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
DesignerSessionSchema.index({ customerId: 1, createdAt: -1 });
DesignerSessionSchema.index({ designerId: 1, status: 1 });
DesignerSessionSchema.index({ status: 1, startTime: 1 });

export default mongoose.model("DesignerSession", DesignerSessionSchema);

================================================================================
FILE: models/Docket.js
================================================================================
import mongoose from "mongoose";

/**
 * Docket Schema
 * 
 * For internal logistics - tracks shipments between hubs
 * and delivery to customers.
 */

const DocketSchema = new mongoose.Schema(
  {
    /* =====================
       BASIC INFO
    ====================== */
    docketNumber: {
      type: String,
      required: true,
      unique: true,
      index: true,
    },

    /* =====================
       ORDER REFERENCES
    ====================== */
    orders: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Order",
        required: true,
      },
    ],

    /* =====================
       HUB ROUTING
    ====================== */
    originHub: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "InternalHub",
      required: true,
      index: true,
    },

    destinationHub: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "InternalHub",
      required: true,
      index: true,
    },

    /* =====================
       STATUS TRACKING
    ====================== */
    currentStatus: {
      type: String,
      enum: [
        "CREATED",
        "DISPATCHED",
        "RECEIVED_AT_HUB",
        "OUT_FOR_DELIVERY",
        "DELIVERED",
      ],
      default: "CREATED",
      index: true,
    },

    statusHistory: [
      {
        status: String,
        timestamp: { type: Date, default: Date.now },
        location: String,
        userId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
      },
    ],

    /* =====================
       DELIVERY
    ====================== */
    deliveryAgent: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      index: true,
    },

    estimatedDelivery: Date,
    actualDelivery: Date,

    /* =====================
       OTP VERIFICATION
    ====================== */
    otpCode: String,
    otpVerified: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true }
);

/* =====================
   AUTO-GENERATE DOCKET NUMBER
====================== */
DocketSchema.pre("save", function (next) {
  if (!this.docketNumber) {
    const ts = Date.now();
    const rand = Math.floor(Math.random() * 10000);
    this.docketNumber = `DCK-${ts}-${rand.toString().padStart(4, "0")}`;
  }
  next();
});

/* =====================
   INDEXES
====================== */
DocketSchema.index({ currentStatus: 1, estimatedDelivery: 1 });
DocketSchema.index({ deliveryAgent: 1, currentStatus: 1 });
DocketSchema.index({ orders: 1 });

export default mongoose.model("Docket", DocketSchema);

================================================================================
FILE: models/Feature.js
================================================================================
import mongoose from "mongoose";

/**
 * Feature Schema
 * 
 * For feature access control - defines all available features
 * that can be enabled/disabled for different user types.
 */

const FeatureSchema = new mongoose.Schema(
  {
    /* =====================
       BASIC INFO
    ====================== */
    key: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      index: true,
      // e.g., "view_brand_kit", "access_delivery_hub", "bulk_upload_csv"
    },

    name: {
      type: String,
      required: true,
      trim: true,
    },

    description: {
      type: String,
      trim: true,
    },

    /* =====================
       CATEGORIZATION
    ====================== */
    category: {
      type: String,
      trim: true,
      index: true,
      // e.g., "ORDERS", "PRODUCTS", "DELIVERY", "ANALYTICS"
    },

    subcategory: String,

    /* =====================
       STATUS
    ====================== */
    isActive: {
      type: Boolean,
      default: true,
    },

    /* =====================
       FEATURE FLAGS
    ====================== */
    isBeta: {
      type: Boolean,
      default: false,
    },

    isPremium: {
      type: Boolean,
      default: false,
    },

    /* =====================
       DEPENDENCIES
    ====================== */
    dependsOn: [
      {
        type: String,
        // Other feature keys this feature depends on
      },
    ],

    /* =====================
       CONFIGURATION SCHEMA
    ====================== */
    configSchema: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
      // JSON Schema for feature configuration
    },

    /* =====================
       METADATA
    ====================== */
    icon: String,
    sortOrder: {
      type: Number,
      default: 0,
    },
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
FeatureSchema.index({ category: 1, sortOrder: 1 });
FeatureSchema.index({ isActive: 1 });

/* =====================
   STATIC METHODS
====================== */

/**
 * Get all features by category
 */
FeatureSchema.statics.getByCategory = async function (category) {
  return await this.find({
    category,
    isActive: true,
  }).sort({ sortOrder: 1 });
};

/**
 * Get all active features
 */
FeatureSchema.statics.getAllActive = async function () {
  return await this.find({ isActive: true }).sort({ category: 1, sortOrder: 1 });
};

export default mongoose.model("Feature", FeatureSchema);

================================================================================
FILE: models/GeoZon.js
================================================================================
import mongoose from "mongoose";

/**
 * HIERARCHICAL GEO ZONE SCHEMA
 * 
 * Supports cascading zones: Country â†’ State â†’ District â†’ City â†’ Zip
 * Priority resolution: Most specific zone wins
 * 
 * Example hierarchy:
 * - USA (Country, Priority 1)
 *   - New York (State, Priority 2)
 *     - Manhattan (City, Priority 4)
 *       - 10001 (Zip, Priority 5)
 */

const GeoZoneSchema = new mongoose.Schema({
  /* =======================
     BASIC INFO
  ======================= */
  name: {
    type: String,
    required: true,
    trim: true,
    index: true
  },

  code: {
    type: String,
    uppercase: true,
    trim: true,
    sparse: true,
    index: true
    // e.g., "US", "NY", "10001"
  },

  currency: {
    type: String,
    default: "INR",
    uppercase: true
    // ISO 4217: USD, EUR, INR, GBP
  },

  /* =======================
     HIERARCHICAL STRUCTURE
  ======================= */
  level: {
    type: String,
    enum: ['COUNTRY', 'STATE', 'DISTRICT', 'CITY', 'ZIP'],
    required: true,
    index: true
  },

  parentZone: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'GeoZone',
    default: null,
    index: true
    // null for top-level (COUNTRY)
  },

  priority: {
    type: Number,
    default: function () {
      // Auto-assign priority based on level
      const priorities = {
        'ZIP': 5,
        'CITY': 4,
        'DISTRICT': 3,
        'STATE': 2,
        'COUNTRY': 1
      };
      return priorities[this.level] || 0;
    },
    index: true
  },

  /* =======================
     RESTRICTIONS
  ======================= */
  isRestricted: {
    type: Boolean,
    default: false,
    index: true
  },

  restrictionReason: {
    type: String,
    trim: true
    // e.g., "Not compliant with local regulations"
  },

  /* =======================
     METADATA
  ======================= */
  isActive: {
    type: Boolean,
    default: true,
    index: true
  },

  description: {
    type: String,
    trim: true
  },

  /* =======================
     NEW FIELDS - Extended Hierarchy Support
  ======================= */
  // Alias for level (for compatibility)
  zoneType: {
    type: String,
    enum: ['COUNTRY', 'STATE', 'DISTRICT', 'CITY', 'ZIP'],
    // Automatically synced with level
  },

  timezone: {
    type: String,
    default: 'Asia/Kolkata',
    // e.g., "America/New_York", "Europe/London"
  },

  deliveryDays: {
    type: Number,
    default: 3,
    // Standard delivery time in days
  },

  holidays: [Date],

  operatingHours: {
    start: String, // e.g., "09:00"
    end: String,   // e.g., "18:00"
    timezone: { type: String, default: 'Asia/Kolkata' },
  },

}, {
  timestamps: true
});

/* =======================
   INDEXES
======================= */
// Compound index for hierarchy queries
GeoZoneSchema.index({ level: 1, parentZone: 1, isActive: 1 });
GeoZoneSchema.index({ priority: -1, isActive: 1 });

/* =======================
   METHODS
======================= */

/**
 * Get all ancestor zones (parent, grandparent, etc.)
 */
GeoZoneSchema.methods.getAncestors = async function () {
  const ancestors = [];
  let currentZone = this;

  while (currentZone.parentZone) {
    const parent = await mongoose.model('GeoZone').findById(currentZone.parentZone);
    if (!parent) break;
    ancestors.push(parent);
    currentZone = parent;
  }

  return ancestors;
};

/**
 * Get all child zones
 */
GeoZoneSchema.methods.getChildren = async function () {
  return await mongoose.model('GeoZone').find({
    parentZone: this._id,
    isActive: true
  }).sort({ priority: -1 });
};

/**
 * Get full hierarchy path (e.g., "USA > New York > Manhattan > 10001")
 */
GeoZoneSchema.methods.getHierarchyPath = async function () {
  const ancestors = await this.getAncestors();
  const path = [...ancestors.reverse().map(a => a.name), this.name];
  return path.join(' > ');
};

/* =======================
   STATIC METHODS
======================= */

/**
 * Resolve geo zone by pincode with cascading fallback
 * Priority: ZIP > CITY > DISTRICT > STATE > COUNTRY
 */
GeoZoneSchema.statics.resolveByPincode = async function (pincode) {
  // First, try to find exact match in GeoZoneMapping
  const GeoZoneMapping = mongoose.model('GeoZoneMapping');

  const mapping = await GeoZoneMapping.findOne({
    $or: [
      { zipCode: pincode },
      {
        zipCodeStart: { $lte: pincode },
        zipCodeEnd: { $gte: pincode }
      }
    ]
  }).populate('geoZone');

  if (mapping && mapping.geoZone) {
    return mapping.geoZone;
  }

  // Fallback: Find default zone for country (if pincode pattern matches)
  // This is a simplified fallback - you can enhance with regex patterns
  const defaultZone = await this.findOne({
    level: 'COUNTRY',
    isActive: true,
    isRestricted: false
  }).sort({ priority: 1 });

  return defaultZone;
};

/**
 * Get most specific zone from a list of zones
 */
GeoZoneSchema.statics.getMostSpecific = function (zones) {
  if (!zones || zones.length === 0) return null;

  // Sort by priority (highest first)
  const sorted = zones.sort((a, b) => b.priority - a.priority);
  return sorted[0];
};

export default mongoose.model("GeoZone", GeoZoneSchema);

================================================================================
FILE: models/GeoZonMapping.js
================================================================================
import mongoose from "mongoose";

const GeoZoneMappingSchema = new mongoose.Schema(
  {
    geoZone: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "GeoZone",
      required: true,
      index: true,
    },

    pincodeStart: {
      type: Number,
      required: true,
    },

    pincodeEnd: {
      type: Number,
      required: true,
    },
  },
  { timestamps: true }
);

/* =========================
   INDEXES (CRITICAL)
========================= */

// Fast lookup: find zone by pincode
GeoZoneMappingSchema.index({
  pincodeStart: 1,
  pincodeEnd: 1,
});

// Prevent exact duplicate ranges
GeoZoneMappingSchema.index(
  { geoZone: 1, pincodeStart: 1, pincodeEnd: 1 },
  { unique: true }
);

/* =========================
   VALIDATION
========================= */

GeoZoneMappingSchema.pre("save", function (next) {
  if (this.pincodeStart > this.pincodeEnd) {
    return next(
      new Error("pincodeStart cannot be greater than pincodeEnd")
    );
  }
  next();
});

export default mongoose.model("GeoZoneMapping", GeoZoneMappingSchema);

================================================================================
FILE: models/InternalHub.js
================================================================================
import mongoose from "mongoose";

/**
 * InternalHub Schema
 * 
 * For delivery hub management - represents physical locations
 * that handle order fulfillment and delivery.
 */

const InternalHubSchema = new mongoose.Schema(
  {
    /* =====================
       BASIC INFO
    ====================== */
    name: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      index: true,
    },

    address: {
      type: String,
      required: true,
      trim: true,
    },

    /* =====================
       MANAGEMENT
    ====================== */
    managerUserId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      index: true,
    },

    /* =====================
       SERVICE AREA
    ====================== */
    serviceablePincodes: [
      {
        type: String,
        trim: true,
      },
    ],

    /* =====================
       CONTACT
    ====================== */
    contactNumber: {
      type: String,
      required: true,
      trim: true,
    },

    alternateContactNumber: String,

    email: {
      type: String,
      trim: true,
      lowercase: true,
    },

    /* =====================
       STATUS
    ====================== */
    isActive: {
      type: Boolean,
      default: true,
      index: true,
    },

    /* =====================
       CAPACITY
    ====================== */
    capacity: {
      maxOrders: Number,
      maxAgents: Number,
    },

    /* =====================
       OPERATING HOURS
    ====================== */
    operatingHours: {
      start: String, // e.g., "09:00"
      end: String,   // e.g., "18:00"
      timezone: { type: String, default: "Asia/Kolkata" },
    },

    holidays: [Date],
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
InternalHubSchema.index({ isActive: 1 });
InternalHubSchema.index({ serviceablePincodes: 1 });

/* =====================
   METHODS
====================== */

/**
 * Check if pincode is serviceable by this hub
 */
InternalHubSchema.methods.canServicePincode = function (pincode) {
  if (!this.isActive) return false;
  return this.serviceablePincodes.includes(pincode);
};

/* =====================
   STATIC METHODS
====================== */

/**
 * Find hub that can service a given pincode
 */
InternalHubSchema.statics.findByPincode = async function (pincode) {
  return await this.findOne({
    isActive: true,
    serviceablePincodes: pincode,
  });
};

export default mongoose.model("InternalHub", InternalHubSchema);

================================================================================
FILE: models/LogisticsProvider.js
================================================================================
import mongoose from "mongoose";

/**
 * LogisticsProvider Schema
 * 
 * For external/internal logistics management - stores configuration
 * for different shipping providers (Delhivery, Shiprocket, Internal).
 * 
 * âš ï¸ SECURITY: apiCredentials should be encrypted before storing.
 */

const LogisticsProviderSchema = new mongoose.Schema(
  {
    /* =====================
       BASIC INFO
    ====================== */
    name: {
      type: String,
      enum: ["DELHIVERY", "SHIPROCKET", "INTERNAL", "BLUEDART", "DTDC", "ECOM_EXPRESS"],
      required: true,
      unique: true,
      index: true,
    },

    displayName: {
      type: String,
      trim: true,
    },

    type: {
      type: String,
      enum: ["INTERNAL", "EXTERNAL"],
      required: true,
      index: true,
    },

    /* =====================
       STATUS
    ====================== */
    isActive: {
      type: Boolean,
      default: true,
      index: true,
    },

    /* =====================
       API CREDENTIALS (ENCRYPTED)
    ====================== */
    apiCredentials: {
      type: mongoose.Schema.Types.Mixed,
      select: false, // Hide by default
      // âš ï¸ Should be encrypted
      // e.g., { apiKey: "...", apiSecret: "...", token: "..." }
    },

    baseUrl: String,

    /* =====================
       SERVICE AREA
    ====================== */
    serviceablePincodes: [
      {
        type: String,
        trim: true,
      },
    ],

    // Alternative: pincode ranges
    serviceableRanges: [
      {
        start: String,
        end: String,
      },
    ],

    // Excluded pincodes (takes precedence)
    excludedPincodes: [String],

    /* =====================
       PRICING RULES
    ====================== */
    pricingRules: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
      // e.g., { baseRate: 50, perKg: 20, codCharges: 30 }
    },

    /* =====================
       DELIVERY ESTIMATES
    ====================== */
    averageDeliveryTime: {
      type: Number, // in days
      default: 3,
    },

    expressDeliveryTime: Number,

    /* =====================
       CAPABILITIES
    ====================== */
    supportsCOD: {
      type: Boolean,
      default: true,
    },

    supportsReverse: {
      type: Boolean,
      default: false,
    },

    maxWeight: Number, // in kg

    /* =====================
       PRIORITY
    ====================== */
    priority: {
      type: Number,
      default: 0,
      index: true,
    },

    /* =====================
       WEBHOOKS
    ====================== */
    webhookUrl: String,
    webhookSecret: {
      type: String,
      select: false,
    },

    /* =====================
       METADATA
    ====================== */
    lastSyncAt: Date,
    syncStatus: {
      type: String,
      enum: ["OK", "ERROR", "PENDING"],
      default: "PENDING",
    },
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
LogisticsProviderSchema.index({ isActive: 1, priority: -1 });
LogisticsProviderSchema.index({ type: 1, isActive: 1 });
LogisticsProviderSchema.index({ serviceablePincodes: 1 });

/* =====================
   METHODS
====================== */

/**
 * Check if pincode is serviceable
 */
LogisticsProviderSchema.methods.canServicePincode = function (pincode) {
  if (!this.isActive) return false;

  // Check exclusions first
  if (this.excludedPincodes?.includes(pincode)) return false;

  // Check direct list
  if (this.serviceablePincodes?.includes(pincode)) return true;

  // Check ranges
  if (this.serviceableRanges?.length) {
    return this.serviceableRanges.some(
      (range) => pincode >= range.start && pincode <= range.end
    );
  }

  return false;
};

/* =====================
   STATIC METHODS
====================== */

/**
 * Find best provider for a pincode
 */
LogisticsProviderSchema.statics.findBestForPincode = async function (pincode) {
  const providers = await this.find({ isActive: true }).sort({ priority: -1 });

  for (const provider of providers) {
    if (provider.canServicePincode(pincode)) {
      return provider;
    }
  }

  return null;
};

export default mongoose.model("LogisticsProvider", LogisticsProviderSchema);

================================================================================
FILE: models/orderModal.js
================================================================================
import mongoose from "mongoose";

const OrderSchema = new mongoose.Schema(
  {
    /* =====================
       CORE REFERENCES
    ====================== */
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },

    product: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Product",
      required: true,
    },

    orderNumber: {
      type: String,
      unique: true,
      index: true,
    },

    /* =====================
       INPUT SIGNALS (NO PRICE LOGIC)
    ====================== */
    quantity: {
      type: Number,
      required: true,
      min: 1,
    },

    selectedDynamicAttributes: [
      {
        attributeType: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "AttributeType",
          required: true,
        },

        attributeName: String,

        pricingKey: {
          type: String, // ðŸ”‘ connects to pricing engine
          required: true,
        },

        value: mongoose.Schema.Types.Mixed,
        label: String,

        uploadedImages: [
          {
            data: Buffer,
            contentType: String,
            filename: String,
          },
        ],
      },
    ],

    /* =====================
       ðŸ”’ PRICE SNAPSHOT (IMMUTABLE)
    ====================== */
    priceSnapshot: {
      type: {
        basePrice: { type: Number, required: true },
        unitPrice: { type: Number, required: true },  // Same as basePrice
        quantity: { type: Number, required: true },

        appliedModifiers: [
          {
            pricingKey: String,
            modifierType: {
              type: String,
              enum: ["PERCENT_INC", "PERCENT_DEC", "FLAT_INC", "FLAT_DEC"],
            },
            value: Number,
            source: {
              type: String,
              enum: ["GLOBAL", "ZONE", "SEGMENT", "PRODUCT", "ATTRIBUTE", "PROMO_CODE"],
            },
            modifierId: {
              type: mongoose.Schema.Types.ObjectId,
              ref: "PriceModifier",
            },
            beforeAmount: Number,
            afterAmount: Number,
            reason: String,
            appliesOn: {
              type: String,
              enum: ["UNIT", "SUBTOTAL"],
            },
          },
        ],

        subtotal: { type: Number, required: true },
        gstPercentage: { type: Number, default: 0 },
        gstAmount: { type: Number, default: 0 },
        totalPayable: { type: Number, required: true },

        currency: { type: String, default: "INR" },
        calculatedAt: { type: Date, default: Date.now },
      },
      required: true,
      immutable: true,  // ðŸš¨ CRITICAL: Prevents price tampering
    },

    /* =====================
       ORDER STATUS FLOW
    ====================== */
    status: {
      type: String,
      enum: [
        "REQUESTED",
        "DESIGN",
        "APPROVED",
        "PRODUCTION",
        "QC",
        "PACKED",
        "DISPATCHED",
        "DELIVERED",
        "CANCELLED",
        "REJECTED",
      ],
      default: "REQUESTED",
      index: true,
    },

    currentDepartment: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Department",
      default: null,
    },

    /* =====================
       DELIVERY
    ====================== */
    address: { type: String, required: true },
    pincode: { type: String, required: true },
    mobileNumber: { type: String, required: true },

    /* =====================
       PAYMENT
    ====================== */
    advancePaid: { type: Number, default: 0 },

    paymentStatus: {
      type: String,
      enum: ["PENDING", "PARTIAL", "COMPLETED"],
      default: "PENDING",
    },

    paymentGatewayInvoiceId: String,

    /* =====================
       LEGACY FIELDS (DO NOT DELETE)
    ====================== */
    paperGSM: String,
    laminationType: String,
    specialEffects: [String],

    /* =====================
       AUDIT
    ====================== */
    notes: String,
    adminNotes: String,

    /* =====================
       NEW FIELDS - Production & Logistics
    ====================== */
    productionJobId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "ProductionJob",
      index: true,
    },

    docketId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Docket",
      index: true,
    },

    logisticsProvider: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "LogisticsProvider",
    },

    trackingId: String,

    /* =====================
       DELIVERY TRACKING
    ====================== */
    estimatedDeliveryDate: Date,
    actualDeliveryDate: Date,

    deliveryStatus: {
      type: String,
      enum: ["PENDING", "DISPATCHED", "IN_TRANSIT", "OUT_FOR_DELIVERY", "DELIVERED", "FAILED"],
      default: "PENDING",
      index: true,
    },

    deliveryOTP: String,

    /* =====================
       ORDER HIERARCHY (for bulk orders)
    ====================== */
    isPriority: {
      type: Boolean,
      default: false,
    },

    parentOrderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
      // For bulk orders (30-in-1)
    },

    childOrders: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Order",
        // For split bulk orders
      },
    ],

    /* =====================
       DESIGNER SERVICE
    ====================== */
    designerSessionId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "DesignerSession",
    },

    /* =====================
       PAYMENT & ERP
    ====================== */
    paymentGatewayId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "PaymentGateway",
    },

    zohoInvoiceId: String,

    /* =====================
       DELIVERY RATING
    ====================== */
    deliveryRating: {
      agentRating: { type: Number, min: 1, max: 5 },
      customerRating: { type: Number, min: 1, max: 5 },
      feedback: String,
      ratedAt: Date,
    },
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
OrderSchema.index({ user: 1, createdAt: -1 });
OrderSchema.index({ status: 1 });
// New indexes for delivery and production tracking
OrderSchema.index({ deliveryStatus: 1, estimatedDeliveryDate: 1 });
OrderSchema.index({ productionJobId: 1, status: 1 });
OrderSchema.index({ docketId: 1 });
OrderSchema.index({ parentOrderId: 1 });

/* =====================
   ORDER NUMBER
====================== */
OrderSchema.pre("save", function (next) {
  if (!this.orderNumber) {
    const ts = Date.now();
    const rand = Math.floor(Math.random() * 10000);
    this.orderNumber = `ORD-${ts}-${rand.toString().padStart(4, "0")}`;
  }
  next();
});

/* =====================
   BACKWARD COMPATIBILITY
====================== */
// Virtual field for legacy code that references totalPrice
OrderSchema.virtual('totalPrice').get(function () {
  return this.priceSnapshot?.totalPayable || 0;
});

// Ensure virtuals are included in JSON and Object representations
OrderSchema.set('toJSON', { virtuals: true });
OrderSchema.set('toObject', { virtuals: true });

export default mongoose.model("Order", OrderSchema);

================================================================================
FILE: models/OrderStateLog.js
================================================================================
import mongoose from "mongoose";

const OrderStateLogSchema = new mongoose.Schema(
  {
    order: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
      required: true,
      index: true,
    },

    fromState: {
      type: String,
      required: true,
    },

    toState: {
      type: String,
      required: true,
    },

    changedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    reason: String,

    timestamp: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: false }
);

export default mongoose.model("OrderStateLog", OrderStateLogSchema);

================================================================================
FILE: models/OrderStateSchema.js
================================================================================
import mongoose from "mongoose";

const OrderStateSchema = new mongoose.Schema(
  {
    code: {
      type: String,
      enum: [
        "REQUESTED",
        "APPROVED",
        "DESIGN",
        "PRODUCTION",
        "QC",
        "PACKED",
        "DISPATCHED",
        "DELIVERED",
        "CANCELLED",
      ],
      required: true,
      unique: true,
      index: true,
    },

    allowedNextStates: {
      type: [String],
      required: true,
    },
  },
  { timestamps: true }
);

export default mongoose.model("OrderState", OrderStateSchema);

================================================================================
FILE: models/PaymentGateway.js
================================================================================
import mongoose from "mongoose";

/**
 * PaymentGateway Schema
 * 
 * For multi-gateway payment support - stores configuration
 * for different payment providers (Razorpay, Stripe, PhonePe).
 * 
 * âš ï¸ SECURITY: publicKey, secretKey, webhookSecret should be
 * encrypted before storing. Use a proper encryption library.
 */

const PaymentGatewaySchema = new mongoose.Schema(
  {
    /* =====================
       BASIC INFO
    ====================== */
    name: {
      type: String,
      enum: ["RAZORPAY", "STRIPE", "PHONEPE", "PAYTM", "CASHFREE"],
      required: true,
      unique: true,
      index: true,
    },

    displayName: {
      type: String,
      trim: true,
    },

    /* =====================
       STATUS
    ====================== */
    isActive: {
      type: Boolean,
      default: true,
      index: true,
    },

    mode: {
      type: String,
      enum: ["SANDBOX", "PRODUCTION"],
      default: "SANDBOX",
    },

    /* =====================
       CREDENTIALS (ENCRYPTED)
    ====================== */
    publicKey: {
      type: String,
      required: true,
      // âš ï¸ Should be encrypted
    },

    secretKey: {
      type: String,
      required: true,
      select: false, // Hide by default
      // âš ï¸ Should be encrypted
    },

    webhookSecret: {
      type: String,
      select: false, // Hide by default
      // âš ï¸ Should be encrypted
    },

    /* =====================
       TRAFFIC DISTRIBUTION
    ====================== */
    priority: {
      type: Number,
      default: 0,
      index: true,
    },

    trafficSplit: {
      type: Number,
      min: 0,
      max: 100,
      default: 100, // Percentage
    },

    /* =====================
       SUPPORTED FEATURES
    ====================== */
    supportedCurrencies: {
      type: [String],
      default: ["INR"],
    },

    supportedMethods: {
      type: [String],
      default: ["UPI", "CARD", "NETBANKING", "WALLET"],
    },

    /* =====================
       PROVIDER CONFIG
    ====================== */
    config: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
      // Provider-specific configuration
    },

    /* =====================
       ENDPOINTS
    ====================== */
    webhookUrl: String,
    callbackUrl: String,

    /* =====================
       METADATA
    ====================== */
    lastTestedAt: Date,
    testResult: {
      success: Boolean,
      message: String,
    },
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
PaymentGatewaySchema.index({ isActive: 1, priority: -1 });

/* =====================
   STATIC METHODS
====================== */

/**
 * Get active payment gateway based on priority and traffic split
 */
PaymentGatewaySchema.statics.getActiveGateway = async function () {
  const gateways = await this.find({ isActive: true }).sort({ priority: -1 });

  if (gateways.length === 0) return null;
  if (gateways.length === 1) return gateways[0];

  // Simple traffic split selection
  const random = Math.random() * 100;
  let cumulative = 0;

  for (const gateway of gateways) {
    cumulative += gateway.trafficSplit;
    if (random <= cumulative) {
      return gateway;
    }
  }

  return gateways[0];
};

export default mongoose.model("PaymentGateway", PaymentGatewaySchema);

================================================================================
FILE: models/PriceBookEntry.js
================================================================================
import mongoose from "mongoose";

const PriceBookEntrySchema = new mongoose.Schema({
  priceBook: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "PriceBook",
    required: true,
    index: true
  },
  product: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Product",
    required: true,
    index: true
  },
  basePrice: { type: Number, required: true },
  compareAtPrice: { type: Number }
}, {
  timestamps: true
});

// Compound index to ensure unique product per price book
PriceBookEntrySchema.index({ priceBook: 1, product: 1 }, { unique: true });

export default mongoose.model("PriceBookEntry", PriceBookEntrySchema);
================================================================================
FILE: models/PriceBook.js
================================================================================
import mongoose from "mongoose";

/**
 * PriceBook Schema - Enhanced for Virtual Price Book System
 * 
 * Supports:
 * - Master/Child hierarchy
 * - Zone and Segment specific price books
 * - Virtual calculated views
 * - Override conflict resolution
 */
const PriceBookSchema = new mongoose.Schema({
  // Basic fields
  name: { 
    type: String, 
    required: true,
    index: true
  },
  
  currency: { 
    type: String, 
    default: "INR" 
  },
  
  isDefault: { 
    type: Boolean, 
    default: false,
    index: true
  },

  // ========================================
  // VIRTUAL PRICE BOOK FIELDS
  // ========================================
  
  /**
   * Master Price Book Flag
   * True = Master book (base prices for all products)
   * False = Child book (overrides or zone/segment specific)
   */
  isMaster: {
    type: Boolean,
    default: false,
    index: true,
    description: "Master price book (true) or child book (false)"
  },
  
  /**
   * Suggested Price from Zoho Books
   * Future integration for syncing with accounting system
   */
  suggestedPrice: {
    type: Number,
    default: null,
    description: "Suggested price from Zoho Books (future integration)"
  },
  
  /**
   * Parent Book Reference
   * Null for master books
   * Points to parent for child books
   */
  parentBook: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'PriceBook',
    default: null,
    index: true,
    description: "Parent price book for hierarchy (null for master)"
  },
  
  /**
   * Geo Zone Link
   * Links this price book to a specific geographic zone
   */
  zone: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'GeoZone',
    default: null,
    index: true,
    description: "Linked geo zone (for zone-specific price books)"
  },
  
  /**
   * User Segment Link
   * Links this price book to a specific user segment
   */
  segment: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'UserSegment',
    default: null,
    index: true,
    description: "Linked user segment (for segment-specific price books)"
  },
  
  // ========================================
  // VIRTUAL BOOK METADATA
  // ========================================
  
  /**
   * Virtual Book Flag
   * True = Calculated view (not stored physically)
   * False = Physical book with stored entries
   */
  isVirtual: {
    type: Boolean,
    default: false,
    index: true,
    description: "True if this is a calculated view, not stored physically"
  },
  
  /**
   * Calculation Logic
   * Defines how virtual prices are calculated
   */
  calculationLogic: {
    type: String,
    enum: ['MASTER_ONLY', 'MASTER_PLUS_ZONE', 'MASTER_PLUS_SEGMENT', 'MASTER_PLUS_BOTH', 'CUSTOM'],
    default: 'MASTER_ONLY',
    description: "Logic for calculating virtual prices"
  },
  
  // ========================================
  // OVERRIDE BEHAVIOR
  // ========================================
  
  /**
   * Override Priority
   * Higher number = higher priority in conflict resolution
   */
  overridePriority: {
    type: Number,
    default: 0,
    index: true,
    description: "Priority for override conflicts (higher wins)"
  },
  
  /**
   * Override Flag
   * True = This book contains only overrides
   * False = This book contains base prices
   */
  isOverride: {
    type: Boolean,
    default: false,
    index: true,
    description: "True if this book contains overrides only"
  },
  
  // ========================================
  // AUDIT TRAIL
  // ========================================
  
  /**
   * Created From
   * Tracks which book this was created from (for cloning)
   */
  createdFrom: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'PriceBook',
    default: null,
    description: "Original book this was created from"
  },
  
  /**
   * Version
   * Incremented on each update for conflict detection
   */
  version: {
    type: Number,
    default: 1,
    description: "Version number for conflict detection"
  },
  
  /**
   * Description
   * Admin notes about this price book
   */
  description: {
    type: String,
    default: "",
    description: "Admin notes about this price book"
  },
  
  /**
   * Active Status
   * Inactive books are not used in calculations
   */
  isActive: {
    type: Boolean,
    default: true,
    index: true,
    description: "Active status for this price book"
  }
  
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// ========================================
// VIRTUAL FIELDS
// ========================================

/**
 * Virtual: Child Books
 * Returns all child books of this price book
 */
PriceBookSchema.virtual('children', {
  ref: 'PriceBook',
  localField: '_id',
  foreignField: 'parentBook',
  justOne: false
});

// ========================================
// INDEXES
// ========================================

// Compound index for zone + segment lookup
PriceBookSchema.index({ zone: 1, segment: 1 });

// Index for master book queries
PriceBookSchema.index({ isMaster: 1, isActive: 1 });

// Index for hierarchy queries
PriceBookSchema.index({ parentBook: 1, isActive: 1 });

// ========================================
// METHODS
// ========================================

/**
 * Check if this is a master price book
 */
PriceBookSchema.methods.isMasterBook = function() {
  return this.isMaster === true;
};

/**
 * Check if this is a child price book
 */
PriceBookSchema.methods.isChildBook = function() {
  return this.parentBook !== null;
};

/**
 * Get full hierarchy path
 */
PriceBookSchema.methods.getHierarchyPath = async function() {
  const path = [this];
  let current = this;
  
  while (current.parentBook) {
    current = await this.model('PriceBook').findById(current.parentBook);
    if (current) path.unshift(current);
  }
  
  return path;
};

// ========================================
// STATIC METHODS
// ========================================

/**
 * Get master price book
 */
PriceBookSchema.statics.getMasterBook = async function() {
  return await this.findOne({ isMaster: true, isActive: true });
};

/**
 * Get price book for zone and segment
 */
PriceBookSchema.statics.getBookForContext = async function(zoneId, segmentId) {
  // Try exact match first
  let book = await this.findOne({
    zone: zoneId,
    segment: segmentId,
    isActive: true
  });
  
  if (book) return book;
  
  // Try zone-only match
  book = await this.findOne({
    zone: zoneId,
    segment: null,
    isActive: true
  });
  
  if (book) return book;
  
  // Try segment-only match
  book = await this.findOne({
    zone: null,
    segment: segmentId,
    isActive: true
  });
  
  if (book) return book;
  
  // Fall back to master
  return await this.getMasterBook();
};

export default mongoose.model("PriceBook", PriceBookSchema);
================================================================================
FILE: models/PriceModifier.js
================================================================================
import mongoose from "mongoose";
import JSONRuleEvaluator from '../services/JSONRuleEvaluator.js';

/**
 * PriceModifier Schema (Enhanced)
 * 
 * Supports both:
 * 1. Automatic pricing adjustments (zone, segment, product, attribute)
 * 2. Promotional offers with codes and usage limits
 */

const PriceModifierSchema = new mongoose.Schema({
  /* =======================
     BASIC INFO
  ======================= */
  name: {
    type: String,
    trim: true,
    index: true
  },

  description: {
    type: String,
    trim: true
  },

  /* =======================
     PROMO CODE (Optional)
     If set, modifier requires code to apply
  ======================= */
  code: {
    type: String,
    uppercase: true,
    trim: true,
    sparse: true,  // Allow null, but unique if present
    index: true
  },

  /* =======================
     SCOPE
  ======================= */
  appliesTo: {
    type: String,
    enum: ["GLOBAL", "ZONE", "SEGMENT", "PRODUCT", "ATTRIBUTE", "COMBINATION"],
    required: true,
  },

  geoZone: { type: mongoose.Schema.Types.ObjectId, ref: "GeoZone" },
  userSegment: { type: mongoose.Schema.Types.ObjectId, ref: "UserSegment" },
  product: { type: mongoose.Schema.Types.ObjectId, ref: "Product" },

  attributeType: { type: mongoose.Schema.Types.ObjectId, ref: "AttributeType" },
  attributeValue: String,

  /* =======================
     JSON-BASED COMBINATION RULES
     For complex targeting with AND/OR logic
  ======================= */
  conditions: {
    type: mongoose.Schema.Types.Mixed,
    default: null,
    description: "JSON logic for combination modifiers"
  },

  /* =======================
     APPLICATION SCOPE (CRITICAL)
  ======================= */
  appliesOn: {
    type: String,
    enum: ["UNIT", "SUBTOTAL"],
    default: "UNIT",
    index: true,
    // UNIT: Applies to unit price (ZONE, SEGMENT, PRODUCT, ATTRIBUTE)
    // SUBTOTAL: Applies to cart total (PROMO_CODE, CART-LEVEL)
  },

  /* =======================
     MODIFIER TYPE & VALUE
  ======================= */
  modifierType: {
    type: String,
    enum: ["PERCENT_INC", "PERCENT_DEC", "FLAT_INC", "FLAT_DEC"],
    required: true
  },

  value: {
    type: Number,
    required: true,
    min: 0
  },

  /* =======================
     QUANTITY CONSTRAINTS
  ======================= */
  minQuantity: Number,
  maxQuantity: Number,

  /* =======================
     USAGE LIMITS (for promo codes)
  ======================= */
  maxUses: {
    type: Number,
    min: 0
  },

  usedCount: {
    type: Number,
    default: 0,
    min: 0
  },

  maxUsesPerUser: {
    type: Number,
    min: 0
  },

  minOrderValue: {
    type: Number,
    min: 0
  },

  maxDiscountAmount: {
    type: Number,
    min: 0
  },

  /* =======================
     VALIDITY PERIOD
  ======================= */
  validFrom: {
    type: Date,
    index: true
  },

  validTo: {
    type: Date,
    index: true
  },

  /* =======================
     STACKING BEHAVIOR
  ======================= */
  isStackable: {
    type: Boolean,
    default: true,
    index: true
  },

  /** higher = stronger */
  priority: {
    type: Number,
    default: 0,
    index: true
  },

  /* =======================
     STATUS
  ======================= */
  isActive: {
    type: Boolean,
    default: true,
    index: true
  },

  /* =======================
     METADATA
  ======================= */
  /** Optional but VERY useful */
  reason: String,

  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },

  tags: [{
    type: String,
    trim: true
  }],

  /* =======================
     NEW FIELDS - 7-Layer Pricing Support
  =======================*/
  isExclusive: {
    type: Boolean,
    default: false,
  },

  timeBased: {
    validFrom: Date,
    validTo: Date,
    daysOfWeek: [Number],
    timeSlots: [String],
  },

  stackingRules: {
    maxStackable: Number,
    excludeModifiers: [{ type: mongoose.Schema.Types.ObjectId, ref: "PriceModifier" }],
  }

}, { timestamps: true });

/* =======================
   INDEXES
======================= */
PriceModifierSchema.index({ isActive: 1, validFrom: 1, validTo: 1 });
PriceModifierSchema.index({ code: 1, isActive: 1 });
PriceModifierSchema.index({ appliesTo: 1, isStackable: 1, priority: -1 });

/* =======================
   METHODS
======================= */

/**
 * Check if modifier is currently valid
 */
PriceModifierSchema.methods.isValid = function () {
  const now = new Date();

  // Check active status
  if (!this.isActive) return false;

  // Check date range (if specified)
  if (this.validFrom && this.validFrom > now) return false;
  if (this.validTo && this.validTo < now) return false;

  // Check usage limits
  if (this.maxUses && this.usedCount >= this.maxUses) return false;

  return true;
};

/**
 * Check if modifier matches given context
 */
PriceModifierSchema.methods.matchesContext = function (context) {
  // Check validity first
  if (!this.isValid()) return false;

  // Check min order value
  if (this.minOrderValue && context.subtotal < this.minOrderValue) {
    return false;
  }

  // Check quantity constraints
  if (this.minQuantity && context.quantity < this.minQuantity) return false;
  if (this.maxQuantity && context.quantity > this.maxQuantity) return false;

  // Check scope matching
  switch (this.appliesTo) {
    case 'GLOBAL':
      return true;  // Always applies

    case 'ZONE':
      return this.geoZone && context.geoZoneId &&
        this.geoZone.toString() === context.geoZoneId.toString();

    case 'SEGMENT':
      return this.userSegment && context.userSegmentId &&
        this.userSegment.toString() === context.userSegmentId.toString();

    case 'PRODUCT':
      return this.product && context.productId &&
        this.product.toString() === context.productId.toString();

    case 'ATTRIBUTE':
      if (!this.attributeType || !context.selectedAttributes) return false;
      return context.selectedAttributes.some(attr =>
        attr.attributeType === this.attributeType.toString() &&
        attr.value === this.attributeValue
      );
    
    case 'COMBINATION':
      if (!this.conditions) {
        console.log(`âš ï¸ COMBINATION modifier ${this._id} has no conditions`);
        return false;
      }
      try {
        const evaluator = new JSONRuleEvaluator();
        const matches = evaluator.evaluate(this.conditions, context);
        console.log(`${matches ? 'âœ…' : 'â­ï¸'} COMBINATION modifier ${this._id} ${matches ? 'matches' : 'does not match'} context`);
        return matches;
      } catch (error) {
        console.error(`âŒ Error evaluating COMBINATION modifier ${this._id}:`, error);
        return false;
      }

    default:
      return false;
  }
};

/**
 * Calculate discount/increase amount for given subtotal
 */
PriceModifierSchema.methods.calculateAdjustment = function (subtotal) {
  let adjustment = 0;

  switch (this.modifierType) {
    case 'PERCENT_INC':
      adjustment = (subtotal * this.value) / 100;
      break;
    case 'PERCENT_DEC':
      adjustment = -(subtotal * this.value) / 100;
      break;
    case 'FLAT_INC':
      adjustment = this.value;
      break;
    case 'FLAT_DEC':
      adjustment = -this.value;
      break;
  }

  // Apply max discount cap if set (only for decreases)
  if (adjustment < 0 && this.maxDiscountAmount) {
    adjustment = Math.max(adjustment, -this.maxDiscountAmount);
  }

  return Math.round(adjustment * 100) / 100;  // Round to 2 decimals
};

export default mongoose.model("PriceModifier", PriceModifierSchema);
================================================================================
FILE: models/PricingCalculationLogschema.js
================================================================================
import mongoose from "mongoose";

const PricingCalculationLogSchema = new mongoose.Schema(
  {
    order: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
      required: true,
      index: true,
    },

    pricingKey: {
      type: String,
      required: true,
    },

    modifier: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "PriceModifier",
    },

    scope: {
      type: String,
      enum: ["GLOBAL", "ZONE", "SEGMENT", "PRODUCT", "ATTRIBUTE"],
      required: true,
    },

    beforeAmount: {
      type: Number,
      required: true,
    },

    afterAmount: {
      type: Number,
      required: true,
    },

    reason: {
      type: String,
      default: "",
    },

    appliedAt: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: true }
);

PricingCalculationLogSchema.index({ order: 1, appliedAt: 1 });

export default mongoose.model(
  "PricingCalculationLog",
  PricingCalculationLogSchema
);

================================================================================
FILE: models/PrintPartnerProfile.js
================================================================================
import mongoose from "mongoose";

const PrintPartnerProfileSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true
    },

    businessName: { type: String, required: true },
    ownerName: { type: String, required: true },

    mobileNumber: { type: String, required: true },
    whatsappNumber: String,
    email: { type: String, required: true },

    gstNumber: String,

    address: {
      fullAddress: String,
      city: String,
      state: String,
      pincode: String
    },

    proofDocument: {
      type: String, // Cloudinary / S3 URL
      required: true
    },

    verificationStatus: {
      type: String,
      enum: ["PENDING", "APPROVED", "REJECTED"],
      default: "PENDING"
    },

    verifiedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User"
    },

    verifiedAt: Date
  },
  { timestamps: true }
);

export default mongoose.model("PrintPartnerProfile", PrintPartnerProfileSchema);

================================================================================
FILE: models/ProductAvailability.js
================================================================================
import mongoose from "mongoose";

const ProductAvailabilitySchema = new mongoose.Schema({
  product: { type: mongoose.Schema.Types.ObjectId, ref: "Product" },
  geoZone: { type: mongoose.Schema.Types.ObjectId, ref: "GeoZone" },
  isSellable: Boolean,
  reason: String
});

export default mongoose.model("ProductAvailability", ProductAvailabilitySchema);

================================================================================
FILE: models/ProductionJob.js
================================================================================
import mongoose from "mongoose";

/**
 * ProductionJob Schema
 * 
 * For job-based production tracking - groups orders into
 * production batches (offset gang or digital direct).
 */

const ProductionJobSchema = new mongoose.Schema(
  {
    /* =====================
       BASIC INFO
    ====================== */
    jobNumber: {
      type: String,
      required: true,
      unique: true,
      index: true,
    },

    jobType: {
      type: String,
      enum: ["OFFSET_GANG", "DIGITAL_DIRECT"],
      required: true,
      index: true,
    },

    /* =====================
       ORDER REFERENCES
    ====================== */
    orders: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Order",
        required: true,
      },
    ],

    /* =====================
       PRODUCTION STATUS
    ====================== */
    currentStation: {
      type: String,
      enum: ["PRINTING", "CUTTING", "LAMINATION", "DISPATCH"],
      index: true,
    },

    filePath: String,

    status: {
      type: String,
      enum: ["PENDING", "IN_PROGRESS", "COMPLETED"],
      default: "PENDING",
      index: true,
    },

    startedAt: Date,
    completedAt: Date,

    /* =====================
       ASSIGNMENT
    ====================== */
    assignedTo: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      index: true,
    },

    /* =====================
       DEPARTMENT LOGS
    ====================== */
    departmentLogs: [
      {
        department: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Department",
        },
        startTime: Date,
        endTime: Date,
        userId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        notes: String,
      },
    ],

    /* =====================
       PREFLIGHT RESULT
    ====================== */
    preflightResult: {
      status: {
        type: String,
        enum: ["PASS", "FAIL", "WARNING"],
      },
      reportUrl: String,
      errorCodes: [String],
      checkedAt: Date,
    },

    /* =====================
       METADATA
    ====================== */
    priority: {
      type: Number,
      default: 0,
    },

    notes: String,
  },
  { timestamps: true }
);

/* =====================
   AUTO-GENERATE JOB NUMBER
====================== */
ProductionJobSchema.pre("save", function (next) {
  if (!this.jobNumber) {
    const prefix = this.jobType === "OFFSET_GANG" ? "OFG" : "DIG";
    const ts = Date.now();
    const rand = Math.floor(Math.random() * 10000);
    this.jobNumber = `${prefix}-${ts}-${rand.toString().padStart(4, "0")}`;
  }
  next();
});

/* =====================
   INDEXES
====================== */
ProductionJobSchema.index({ jobType: 1, currentStation: 1 });
ProductionJobSchema.index({ status: 1, createdAt: -1 });
ProductionJobSchema.index({ orders: 1 });
ProductionJobSchema.index({ assignedTo: 1, status: 1 });

export default mongoose.model("ProductionJob", ProductionJobSchema);

================================================================================
FILE: models/productModal.js
================================================================================
import mongoose from "mongoose";

const ProductSchema = new mongoose.Schema(
  {
    /* =======================
       BASIC PRODUCT INFO
    ======================= */
    category: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Category",
      required: true,
      index: true,
    },

    subcategory: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "SubCategory",
    },

    name: {
      type: String,
      required: true,
      trim: true,
      index: true,
    },

    description: {
      type: String,
      default: "",
    },

    // âš ï¸ LEGACY SUPPORT ONLY
    descriptionArray: {
      type: [String],
      default: [],
    },

    productType: {
      type: String,
      default: "",
      trim: true,
    },

    image: {
      type: String,
      default: null,
    },

    /* =======================
       UI DISPLAY OPTIONS ONLY
       (NO PRICING / NO LOGIC)
    ======================= */
    options: [
      {
        name: { type: String, required: true },
        description: String,
        image: String,
      },
    ],

    /* =======================
       LEGACY FILTERS
       âš ï¸ READ-ONLY
       âš ï¸ DO NOT USE IN NEW CODE
    ======================= */
    filters: {
      type: Object,
      select: false, // hides from normal queries
    },

    /* =======================
       MODERN DYNAMIC ATTRIBUTES
    ======================= */
    dynamicAttributes: [
      {
        attributeType: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "AttributeType",
          required: true,
        },

        dependsOn: {
          attribute: {
            type: mongoose.Schema.Types.ObjectId,
            ref: "AttributeType",
          },
          value: String,
        },

        isEnabled: {
          type: Boolean,
          default: true,
        },

        displayOrder: {
          type: Number,
          default: 0,
        },

        isRequired: {
          type: Boolean,
          default: false,
        },
      },
    ],

    /* =======================
       SINGLE SOURCE OF TRUTH
       FOR QUANTITY
    ======================= */
    quantityConfig: {
      quantityType: {
        type: String,
        enum: ["SIMPLE", "STEP_WISE", "RANGE_WISE"],
        default: "SIMPLE",
      },

      minQuantity: Number,
      maxQuantity: Number,
      multiples: Number,

      stepWiseQuantities: [Number],

      rangeWiseQuantities: [
        {
          min: Number,
          max: Number,
          label: String,
        },
      ],
    },

    /* =======================
       FILE VALIDATION RULES
    ======================= */
    fileRules: {
      maxFileSizeMB: Number,
      minWidth: Number,
      maxWidth: Number,
      minHeight: Number,
      maxHeight: Number,
      blockedFormats: {
        type: [String],
        default: [],
      },
    },

    /* =======================
       TAX & DISPLAY
    ======================= */
    additionalDesignCharge: {
      type: Number,
      default: 0,
    },

    gstPercentage: {
      type: Number,
      default: 0,
      min: 0,
      max: 100,
    },

    showPriceIncludingGst: {
      type: Boolean,
      default: false,
    },

    instructions: {
      type: String,
      default: "",
    },

    /* =======================
       PRODUCT LIFECYCLE
    ======================= */
    isActive: {
      type: Boolean,
      default: false,
      index: true,
    },

    /* =======================
       PRODUCTION WORKFLOW
    ======================= */
    productionSequence: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Department",
      },
    ],

    /* =======================
       NEW FIELDS - Zoho Integration
    ======================= */
    suggestedBaseCost: {
      type: Number,
      // From Zoho integration
    },

    /* =======================
       BILL OF MATERIALS
    ======================= */
    bom: [
      {
        material: String,
        quantity: Number,
        unit: String,
      },
    ],

    /* =======================
       CROSS-SELL & UP-SELL
    ======================= */
    relatedProducts: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Product",
      },
    ],

    frequentlyBoughtTogether: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Product",
      },
    ],

    keywords: [
      {
        type: String,
        trim: true,
        // For SEO and up-sell
      },
    ],

    /* =======================
       VIEW CONFIGURATION
    ======================= */
    views: {
      defaultView: {
        type: String,
        default: "ATTRIBUTE_BASED",
      },
      alternativeView: {
        type: String,
        default: "EXPANDABLE_SECTION",
      },
    },

    /* =======================
       AVAILABILITY RULES
    ======================= */
    availabilityRules: [
      {
        geoZoneId: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "GeoZone",
        },
        isSellable: Boolean,
        reason: String,
      },
    ],
  },
  { timestamps: true }
);

/* =======================
   INDEXES
======================= */
ProductSchema.index({ category: 1 });
ProductSchema.index({ name: 1 });

export default mongoose.model("Product", ProductSchema);

================================================================================
FILE: models/reviewModal.js
================================================================================
import mongoose from "mongoose";

const ReviewSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: false, // Made optional for non-logged-in users
    },
    userName: {
      type: String,
      required: true,
    },
    rating: {
      type: Number,
      required: true,
      min: 1,
      max: 5,
    },
    comment: {
      type: String,
      required: true,
    },
  },
  { timestamps: true }
);

export default mongoose.model("Review", ReviewSchema);



================================================================================
FILE: models/SegmentPricebook.js
================================================================================
import mongoose from "mongoose";

const SegmentPriceBookSchema = new mongoose.Schema({
  userSegment: { type: mongoose.Schema.Types.ObjectId, ref: "UserSegment" },
  priceBook: { type: mongoose.Schema.Types.ObjectId, ref: "PriceBook" },
  priority: Number
});

export default mongoose.model("SegmentPriceBook", SegmentPriceBookSchema);

================================================================================
FILE: models/sequenceModal.js
================================================================================
import mongoose from "mongoose";

const SequenceSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    category: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Category",
      required: true,
    },
    // Keep subcategory for backward compatibility during migration (will be removed later)
    subcategory: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "SubCategory",
      required: false,
    },
    departments: [
      {
        department: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Department",
          required: true,
        },
        order: {
          type: Number,
          required: true,
        },
      },
    ],
    attributes: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "AttributeType",
      },
    ],
    isDefault: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true }
);

// Index for faster queries
SequenceSchema.index(
  { category: 1, subcategory: 1, isDefault: 1 },
  { partialFilterExpression: { isDefault: true } }
);

SequenceSchema.index({ isDefault: 1 });

export default mongoose.model("Sequence", SequenceSchema);



================================================================================
FILE: models/subAttributeSchema.js
================================================================================
import mongoose from "mongoose";

const SubAttributeSchema = new mongoose.Schema(
  {
    /* =======================
       ATTRIBUTE LINK
    ======================= */
    parentAttribute: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "AttributeType",
      required: true,
      index: true,
    },

    /* =======================
       NESTING CONTROL
       - ROOT LEVEL: parentValue = "__root__"
       - CHILD LEVEL: parentValue = parent.value
    ======================= */
    parentValue: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
    },

    /* =======================
       SYSTEM VALUE (LEAF STORED)
    ======================= */
    value: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
    },

    /* =======================
       DISPLAY
    ======================= */
    label: {
      type: String,
      required: true,
      trim: true,
    },

    image: {
      type: String,
      default: null,
    },

    /* =======================
       PRICING ENGINE BRIDGE
       (USED ONLY FOR LEAF)
    ======================= */
    pricingKey: {
      type: String,
      required: true,
      uppercase: true,
      trim: true,
      index: true,
    },

    isEnabled: {
      type: Boolean,
      default: true,
      index: true,
    },
  },
  { timestamps: true }
);

/* =======================
   PREVENT DUPLICATES
======================= */
SubAttributeSchema.index(
  { parentAttribute: 1, parentValue: 1, value: 1 },
  { unique: true }
);

export default mongoose.model("SubAttribute", SubAttributeSchema);

================================================================================
FILE: models/subcategoryModal.js
================================================================================
import mongoose from "mongoose";

const SubCategorySchema = new mongoose.Schema(
  {
    category: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Category",
      required: true,
    },
    // Optional parent subcategory for nested subcategories (unlimited depth)
    parent: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "SubCategory",
      default: null,
    },
    name: { type: String, required: true },
    description: String,
    image: String, // Image URL
    slug: { type: String, unique: true }, // URL-friendly identifier (e.g., "gloss-finish")
    sortOrder: {
      type: Number,
      default: 0,
    }, // Sort order for displaying subcategories (lower numbers appear first)
  },
  { timestamps: true }
);

// Index for faster parent queries
SubCategorySchema.index({ parent: 1 });
SubCategorySchema.index({ category: 1, parent: 1 });
SubCategorySchema.index({ parent: 1, sortOrder: 1 });

export default mongoose.model("SubCategory", SubCategorySchema);

================================================================================
FILE: models/uploadModal.js
================================================================================
import mongoose from "mongoose";

const designSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    height: {
      type: Number,
      required: true,
    },
    width: {
      type: Number,
      required: true,
    },
    description: {
      type: String,
      default: "",
    },
    // Safe area (critical content must be within this area)
    safeArea: {
      top: { type: Number, default: 0 },
      bottom: { type: Number, default: 0 },
      left: { type: Number, default: 0 },
      right: { type: Number, default: 0 }
    },
    // Bleed area (extra area that gets trimmed off)
    bleedArea: {
      top: { type: Number, default: 0 },
      bottom: { type: Number, default: 0 },
      left: { type: Number, default: 0 },
      right: { type: Number, default: 0 }
    },
    // Front image (COMPULSORY)
    frontImage: {
      data: { type: Buffer, required: true }, // Required
      contentType: { type: String, required: true }, // Required
      filename: String,
      size: Number
    },
    // Back image (OPTIONAL)
    backImage: {
      data: Buffer,
      contentType: String,
      filename: String,
      size: Number
    }
  },
  { timestamps: true }
);

export default mongoose.model("Design", designSchema);
================================================================================
FILE: models/User.js
================================================================================
import mongoose from "mongoose";

const userSchema = new mongoose.Schema(
  {
    name: { type: String, required: false }, // Made optional for customer signup
    firstName: { type: String, required: false },
    lastName: { type: String, required: false },
    email: { type: String, required: true, unique: true },
    mobileNumber: { type: String, required: false },
    countryCode: { type: String, required: false },
    role: { type: String, enum: ["user", "admin", "emp"], default: "user" },
    password: { type: String, required: false }, // Optional - set later in signup flow
    userSegment: { type: mongoose.Schema.Types.ObjectId, ref: "UserSegment" },
    approvalStatus: { type: String, enum: ["pending", "approved", "rejected"], default: "pending" },
    userType: { type: String, enum: ["customer", "print partner", "corporate"], default: "customer" },
    signupIntent: {
      type: String,
      enum: ["CUSTOMER", "PRINT_PARTNER", "CORPORATE"],
      required: true
    },
    // Email verification fields
    isEmailVerified: { type: Boolean, default: false },
    emailOtp: { type: String }, // Hashed OTP
    emailOtpExpiresAt: { type: Date },

    /* =====================
       NEW FIELDS - Dynamic PMS
    ====================== */
    userTypeId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "UserType",
      index: true,
    },

    /* =====================
       FINANCIAL
    ====================== */
    creditLimit: {
      type: Number,
      default: 0,
      min: 0,
    },

    paymentTerms: {
      type: String,
      // e.g., "NET30", "PREPAID", "COD"
    },

    walletBalance: {
      type: Number,
      default: 0,
    },

    commissionRate: {
      type: Number,
      min: 0,
      max: 100,
      // For agents/distributors
    },

    /* =====================
       TERRITORY (for distributors/branches)
    ====================== */
    territoryAccess: [
      {
        type: String,
        // Pincode or zone codes
      },
    ],

    /* =====================
       HUB & CLIENT MANAGEMENT
    ====================== */
    assignedHub: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "InternalHub",
      // For delivery agents
    },

    clients: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
        // For agents managing clients
      },
    ],

    /* =====================
       BRAND KIT
    ====================== */
    brandKit: {
      logo: String,
      primaryColor: String,
      secondaryColor: String,
      fonts: [String],
      templates: [
        {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Design",
        },
      ],
    },
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
userSchema.index({ userTypeId: 1, territoryAccess: 1 });
userSchema.index({ commissionRate: 1 });
userSchema.index({ assignedHub: 1 });

export const User = mongoose.model("User", userSchema);


================================================================================
FILE: models/UserSegment.js
================================================================================
import mongoose from "mongoose";

const UserSegmentSchema = new mongoose.Schema({
  code: {
    type: String,
    enum: ["RETAIL", "PRINT_PARTNER", "CORPORATE", "VIP"],
    unique: true,
    required: true
  },
  name: String,
  isDefault: { type: Boolean, default: false }
}, { timestamps: true });

export default mongoose.model("UserSegment", UserSegmentSchema);

================================================================================
FILE: models/UserType.js
================================================================================
import mongoose from "mongoose";

/**
 * UserType Schema
 * 
 * For dynamic privilege management system (PMS) - replaces
 * fixed role system with configurable user types and features.
 */

const UserTypeSchema = new mongoose.Schema(
  {
    /* =====================
       BASIC INFO
    ====================== */
    name: {
      type: String,
      enum: ["AGENT", "CORPORATE", "DISTRIBUTOR", "BRANCH", "HUB", "RETAIL", "VIP"],
      required: true,
      index: true,
    },

    code: {
      type: String,
      required: true,
      unique: true,
      uppercase: true,
      trim: true,
      index: true,
    },

    displayName: {
      type: String,
      trim: true,
    },

    description: String,

    /* =====================
       PRICING TIER
    ====================== */
    pricingTier: {
      type: Number,
      min: 0,
      max: 4,
      default: 0,
      index: true,
      // 0 = Retail (highest price)
      // 4 = VIP (lowest price)
    },

    /* =====================
       HIERARCHY
    ====================== */
    parentType: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "UserType",
      default: null,
      index: true,
    },

    /* =====================
       STATUS
    ====================== */
    isActive: {
      type: Boolean,
      default: true,
      index: true,
    },

    /* =====================
       FEATURES
    ====================== */
    features: [
      {
        featureKey: {
          type: String,
          required: true,
        },
        isEnabled: {
          type: Boolean,
          default: false,
        },
        config: {
          type: mongoose.Schema.Types.Mixed,
          default: {},
        },
      },
    ],

    /* =====================
       UI CONFIGURATION
    ====================== */
    viewConfig: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
      // JSON configuration for UI customization
    },

    /* =====================
       PERMISSIONS
    ====================== */
    permissions: [
      {
        resource: String, // e.g., "orders", "products", "users"
        actions: [String], // e.g., ["read", "write", "delete"]
      },
    ],

    /* =====================
       LIMITS
    ====================== */
    limits: {
      maxOrders: Number,
      maxClients: Number,
      maxCreditLimit: Number,
    },
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
UserTypeSchema.index({ isActive: 1, pricingTier: 1 });

/* =====================
   METHODS
====================== */

/**
 * Check if feature is enabled for this user type
 */
UserTypeSchema.methods.hasFeature = function (featureKey) {
  const feature = this.features.find((f) => f.featureKey === featureKey);
  return feature?.isEnabled || false;
};

/**
 * Get feature config
 */
UserTypeSchema.methods.getFeatureConfig = function (featureKey) {
  const feature = this.features.find((f) => f.featureKey === featureKey);
  return feature?.config || {};
};

/**
 * Get all ancestors (parent types)
 */
UserTypeSchema.methods.getAncestors = async function () {
  const ancestors = [];
  let current = this;

  while (current.parentType) {
    const parent = await mongoose.model("UserType").findById(current.parentType);
    if (!parent) break;
    ancestors.push(parent);
    current = parent;
  }

  return ancestors;
};

export default mongoose.model("UserType", UserTypeSchema);

================================================================================
FILE: models/ZohoSyncLog.js
================================================================================
import mongoose from "mongoose";

/**
 * ZohoSyncLog Schema
 * 
 * For ERP integration audit trail - tracks all sync operations
 * between the application and Zoho (invoices, inventory, contacts).
 */

const ZohoSyncLogSchema = new mongoose.Schema(
  {
    /* =====================
       REFERENCE
    ====================== */
    orderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Order",
      index: true,
    },

    /* =====================
       SYNC DETAILS
    ====================== */
    syncType: {
      type: String,
      enum: ["INVOICE", "INVENTORY", "CONTACT", "PAYMENT", "CREDIT_NOTE"],
      required: true,
      index: true,
    },

    status: {
      type: String,
      enum: ["PENDING", "SUCCESS", "FAILED", "RETRYING"],
      default: "PENDING",
      index: true,
    },

    /* =====================
       REQUEST/RESPONSE DATA
    ====================== */
    requestData: {
      type: mongoose.Schema.Types.Mixed,
    },

    responseData: {
      type: mongoose.Schema.Types.Mixed,
    },

    /* =====================
       ZOHO REFERENCE
    ====================== */
    zohoId: {
      type: String,
      index: true,
    },

    zohoModule: String, // e.g., "invoices", "contacts"

    /* =====================
       ERROR HANDLING
    ====================== */
    errorMessage: String,
    errorCode: String,

    retryCount: {
      type: Number,
      default: 0,
    },

    maxRetries: {
      type: Number,
      default: 3,
    },

    nextRetryAt: Date,

    /* =====================
       TIMING
    ====================== */
    syncedAt: Date,
    
    syncDuration: {
      type: Number, // in milliseconds
    },
  },
  { timestamps: true }
);

/* =====================
   INDEXES
====================== */
ZohoSyncLogSchema.index({ orderId: 1, syncType: 1 });
ZohoSyncLogSchema.index({ status: 1, nextRetryAt: 1 });
ZohoSyncLogSchema.index({ zohoId: 1 });
ZohoSyncLogSchema.index({ createdAt: -1 });

/* =====================
   METHODS
====================== */

/**
 * Mark sync as successful
 */
ZohoSyncLogSchema.methods.markSuccess = function (zohoId, responseData) {
  this.status = "SUCCESS";
  this.zohoId = zohoId;
  this.responseData = responseData;
  this.syncedAt = new Date();
  return this.save();
};

/**
 * Mark sync as failed and schedule retry
 */
ZohoSyncLogSchema.methods.markFailed = function (errorMessage, errorCode) {
  this.status = this.retryCount < this.maxRetries ? "RETRYING" : "FAILED";
  this.errorMessage = errorMessage;
  this.errorCode = errorCode;
  this.retryCount += 1;

  if (this.status === "RETRYING") {
    // Exponential backoff: 5min, 15min, 45min
    const delayMinutes = Math.pow(3, this.retryCount) * 5;
    this.nextRetryAt = new Date(Date.now() + delayMinutes * 60 * 1000);
  }

  return this.save();
};

/* =====================
   STATIC METHODS
====================== */

/**
 * Get pending retries
 */
ZohoSyncLogSchema.statics.getPendingRetries = async function () {
  return await this.find({
    status: "RETRYING",
    nextRetryAt: { $lte: new Date() },
  }).limit(100);
};

export default mongoose.model("ZohoSyncLog", ZohoSyncLogSchema);
