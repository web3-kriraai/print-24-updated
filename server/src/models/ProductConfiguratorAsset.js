import mongoose from "mongoose";

/**
 * ProductConfiguratorAsset Schema
 * 
 * Stores pre-rendered images for each unique combination of configurator attributes.
 * This model is the core of the Matrix Strategy - enabling O(1) image lookups.
 * 
 * Example: A product with 3 attributes (Material, Color, Finish) each with values:
 * - Material: [leather, fabric, vinyl]
 * - Color: [red, blue, green]
 * - Finish: [matte, gloss]
 * 
 * Will generate 3×3×2 = 18 asset records, one for each combination.
 */
const ProductConfiguratorAssetSchema = new mongoose.Schema(
    {
        // Reference to the product this asset belongs to
        product: {
            type: mongoose.Schema.Types.ObjectId,
            ref: "Product",
            required: true,
            index: true,
        },

        // The attribute combination this asset represents
        // Stored as a Map for flexibility with different attribute counts
        // Example: { "material": "leather", "color": "red", "finish": "matte" }
        attributeCombination: {
            type: Map,
            of: String,
            required: true,
        },

        // Pre-computed hash for O(1) lookups
        // Generated by joining attribute values in order: "leather_red_matte"
        combinationHash: {
            type: String,
            required: true,
            trim: true,
            index: true,
        },

        // The expected filename (for bulk upload matching)
        // Example: "prod_leather_red_matte.jpg"
        expectedFilename: {
            type: String,
            trim: true,
        },

        // Cloudinary URL for the uploaded image
        imageUrl: {
            type: String,
            trim: true,
        },

        // Cloudinary public_id for deletion/management
        cloudinaryPublicId: {
            type: String,
            trim: true,
        },

        // Upload status: pending (awaiting upload), uploaded (ready), missing (flagged)
        status: {
            type: String,
            enum: ["pending", "uploaded", "missing"],
            default: "pending",
            index: true,
        },

        // File metadata
        fileSize: {
            type: Number,
            default: 0,
        },

        // Image dimensions (for validation)
        imageWidth: Number,
        imageHeight: Number,

        // Tracking who uploaded the asset
        uploadedAt: Date,
        uploadedBy: {
            type: mongoose.Schema.Types.ObjectId,
            ref: "User",
        },

        // Display order for the matrix view
        displayOrder: {
            type: Number,
            default: 0,
        },

        // Whether this asset is active (soft delete)
        isActive: {
            type: Boolean,
            default: true,
        },
    },
    { timestamps: true }
);

// Compound index for efficient lookups by product + hash
ProductConfiguratorAssetSchema.index(
    { product: 1, combinationHash: 1 },
    { unique: true }
);

// Index for finding assets by status within a product
ProductConfiguratorAssetSchema.index({ product: 1, status: 1 });

// Index for finding active assets
ProductConfiguratorAssetSchema.index({ product: 1, isActive: 1 });

// Virtual for checking if asset has an image
ProductConfiguratorAssetSchema.virtual("hasImage").get(function () {
    return this.status === "uploaded" && !!this.imageUrl;
});

// Static method to get completion stats for a product
ProductConfiguratorAssetSchema.statics.getCompletionStats = async function (productId) {
    const stats = await this.aggregate([
        { $match: { product: new mongoose.Types.ObjectId(productId), isActive: true } },
        {
            $group: {
                _id: "$status",
                count: { $sum: 1 },
            },
        },
    ]);

    const result = { pending: 0, uploaded: 0, missing: 0, total: 0 };
    stats.forEach((s) => {
        result[s._id] = s.count;
        result.total += s.count;
    });
    result.completionPercentage =
        result.total > 0 ? ((result.uploaded / result.total) * 100).toFixed(1) : 0;

    return result;
};

// Instance method to mark as uploaded
ProductConfiguratorAssetSchema.methods.markAsUploaded = function (
    imageUrl,
    cloudinaryPublicId,
    userId
) {
    this.imageUrl = imageUrl;
    this.cloudinaryPublicId = cloudinaryPublicId;
    this.status = "uploaded";
    this.uploadedAt = new Date();
    this.uploadedBy = userId;
    return this.save();
};

export default mongoose.model(
    "ProductConfiguratorAsset",
    ProductConfiguratorAssetSchema
);
